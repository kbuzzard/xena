import data.fintype data.nat.modeq data.fintype data.set.finite data.nat.prime set_theory.cardinal tactic.norm_num
universe u
variable α : Type u
local attribute [instance,priority 0] classical.prop_decidable
noncomputable theory

open fintype
instance fintype_subtype_of_fintype (α : Type u) (p : α → Prop) [fintype α] : fintype {a // p a}:=begin
  cases _inst_1,
  let s := finset.filter p elems,
  have : ∀ a : α, a ∈ s ↔ p a,
    assume a,simp[s],split,
    exact λ h,h.right,
    exact λ h, ⟨complete a, h⟩,
  exact set.fintype_of_finset s this,
end

lemma fintype_of_injective {α β : Type u} {f : α → β} [fintype β] (h: function.injective f) : fintype α := begin
  unfold function.injective at h,
  have h₁: cardinal.mk α ≤ cardinal.mk β,
    split,split,swap,exact f,exact h,
  have h₂:= cardinal.fintype_card β,
  have h₃:= cardinal.nat_lt_omega (card β),rw h₂ at h₁,
  have h₄ :=lt_of_le_of_lt h₁ h₃,
  rw cardinal.lt_omega_iff_fintype at h₄,
  exact classical.choice h₄,
end

theorem nodup_pair : ∀ a b : α, a ≠ b → list.nodup [a, b] := by simp [list.nodup]

def pair_finset (a b : α) (h : a ≠ b) : finset α := ⟨[a, b], nodup_pair α a b h⟩

theorem involution_parity {α : Type u} {f : α → α} [fintype α] : (∀ x : α, f x ≠ x) → (∀ x : α, f (f x) = x) → 2 ∣ card α := begin
 assume hs hf,
 let s := λ (a : α), pair_finset α a (f a) (hs a).symm,  
 have : ∀ u : finset α,  (∀ x : α, x ∈ u → f x ∈ u) → 2 ∣ finset.card u,
  assume u,
  apply finset.strong_induction_on u,
  assume u ht hu,
  cases classical.em (u = finset.empty),
  rw h,simp [finset.card,finset.empty],
  have := finset.exists_mem_of_ne_empty h,
  cases this with x hx,
  let t₁ := s x,
  let t₂ := @set.finite.to_finset α {x | x ∉ t₁ ∧ x ∈ u} ⟨fintype_subtype_of_fintype _ _ ⟩,
  have h2t₂:∀ x : α, x ∈ u → (x ∉ t₁ ↔ x ∈ t₂),
   simp [t₂],assume x hx,exact ⟨λ h,⟨h,hx⟩,λ h,h.left⟩,
  have hxt₁ : x ∈ t₁,
   simp[t₁,s],simp[pair_finset],
  have hfxt₁ : f x ∈ t₁,
   simp[t₁,s,pair_finset],
  have ht₂u : t₂ ⊂ u,
   unfold has_ssubset.ssubset,
   rw finset.subset_iff,
   split, simp[t₂],
   rw [finset.subset_iff,classical.not_forall],
   existsi x,
   rw not_imp,split, exact hx,
   have:=iff.mpr not_not hxt₁,
   exact iff.mp (iff_false_left this) (h2t₂ x hx), 
  have h2t₂:(∀ (x : α), x ∈ t₂ → f x ∈ t₂),
   simp[t₂],
   assume x₁ hx₁ hx₁u,split,
   assume hfx₁,
   simp[t₁,s,pair_finset] at hx₁ hfx₁,
   cases hfx₁,
   have := hf x₁,rw hfx₁ at this,
   simp [this.symm] at hx₁,trivial,
   have:=hf x,rw ←hfx₁ at this,
   have j:=hf x₁, rw j at this,
   simp [this] at hx₁, trivial,
   exact hu x₁ hx₁u,
  have:= ht t₂ ht₂u h2t₂,
  have huc : u = insert (f x) (insert x t₂),
   rw finset.ext,
   assume a,split,simp [t₂],
   cases classical.em (a ∈ t₁),
   simp [t₁,s,pair_finset] at h_1,
   assume h_2,
   cases h_1,simp[h_1],
   simp[h_1],simp[h_1],
   assume h, simp[h],
   simp[t₂],assume h,
   cases h,rwa h_1,
   cases h_1,
   rw h_1,exact hu x hx,
   exact h_1.right,
  have hxt₂ : x ∉ t₂,
   simp[t₂],assume h,
   exact absurd hxt₁ h,
  have hfxt₂ : f x ∉ insert x t₂,
   simp[t₂],assume h,
   cases h,
   exact absurd h_1 (hs x),
   exact absurd hfxt₁ h_1.left,
  rw huc,
  rw [finset.card_insert_of_not_mem hfxt₂,finset.card_insert_of_not_mem hxt₂],
  simp,exact iff.mp (nat.dvd_add_iff_right this) (by simp),
 unfold card finset.univ, cases _inst_1,
 have helems: (∀ (x : α), x ∈ elems → f x ∈ elems) := λ x hx, complete (f x),
 have := this elems helems,simp [this], 
end

variables (p : ℕ) (hp : nat.prime p) (hp1 : p ≡ 1 [MOD 4])

open int

def S : set (ℕ × ℕ × ℕ) := {x | ((x.1) * (x.1) + 4 * x.2.1 * x.2.2 = ↑p) ∧ 0 < x.1 ∧ 0 < x.2.1 ∧ 0 < x.2.2}

instance fintype_S : fintype (S p) := begin 
  have i1 := prod.fintype (fin (p+1)) (fin (p+1)),

  have i := prod.fintype (fin(p+1)) (fin(p+1) × (fin(p+1))),clear i1,
  have hv : ∀ v : ℕ × ℕ × ℕ, v ∈ S p → v.1 < p + 1 ∧ v.2.1 < p + 1 ∧ v.2.2 < (p+1) := λ ⟨x, y, z⟩,begin
    assume h, simp [S] at h,simp,split,
    suffices : x ≤ p,
      exact nat.lt_succ_of_le this,
    cases x,exact absurd h.right.left dec_trivial,rw ←h.left,
    rw [nat.mul_succ,add_comm (nat.succ x * x),add_assoc],
    exact nat.le_add_right _ _,split,
    suffices : y ≤ p,
      exact nat.lt_succ_of_le this,
    cases z,exact absurd h.right.right.right dec_trivial,
    rw [←h.left,nat.mul_succ,nat.succ_mul 3 y,←add_assoc,←add_assoc],
    exact nat.le_add_left _ _,
    suffices : z ≤ p,
      exact nat.lt_succ_of_le this,
    rw [mul_right_comm 4] at h,
    cases y,exact absurd h.right.right.left dec_trivial,
    rw [←h.left,nat.mul_succ,nat.succ_mul 3 z,←add_assoc,←add_assoc],
    exact nat.le_add_left _ _,
  end,
  let f : S p → fin (p+1) × fin (p+1) × fin (p+1) := λ v,⟨⟨v.val.1, (hv v.val v.property).left⟩, ⟨v.val.2.1, (hv v.val v.property).right.left⟩, ⟨v.val.2.2, (hv v.val v.property).right.right⟩⟩,
  have hf : function.injective f,
    assume a b,cases a with a ha, cases b with b hb,
    cases a with a₁ a₂,cases a₂ with a₂ a₃,
    cases b with b₁ b₂,cases b₂ with b₂ b₃,
    simp [f],assume h1 h2 h3,
    have h1 : (⟨a₁, _⟩ : fin (p+1)).val = (⟨b₁, _⟩ : fin (p+1)).val,rw h1,simp at h1,
    have h2 : (⟨a₂, _⟩ : fin (p+1)).val = (⟨b₂, _⟩ : fin (p+1)).val,rw h2,simp at h2,
    have h3 : (⟨a₃, _⟩ : fin (p+1)).val = (⟨b₃, _⟩ : fin (p+1)).val,rw h3,simp at h3,
    simp[h1,h2,h3],
  exact fintype_of_injective hf,
end

def f₁ : (ℕ × ℕ × ℕ) → (ℕ × ℕ × ℕ) := λ ⟨x, y, z⟩, (x, z, y)
def f₂ : (ℕ × ℕ × ℕ) → (ℕ × ℕ × ℕ) := λ ⟨x, y, z⟩, if x + z < y then (x + 2 * z, z, int.nat_abs ((↑y:ℤ) - ↑x - ↑z)) else (if 2 * y < x then (int.nat_abs (↑x - (2:ℤ) * ↑y), int.nat_abs (↑x - ↑y + ↑z), y) else (int.nat_abs (2 * ↑y - ↑x), y, int.nat_abs(x - y + z)))
lemma f₁_S : ∀ x : (ℕ × ℕ × ℕ), x ∈ S p → f₁ x ∈ S p := λ ⟨x, y, z⟩, begin
 simp[S,f₁],rw mul_assoc 4, rw[mul_comm y, ←mul_assoc],assume h hx0 hy0 hz0,exact ⟨h,hx0,hz0,hy0⟩,
end
lemma f₁_invo_on_S : ∀ x : (ℕ × ℕ × ℕ), x ∈ S p → f₁ (f₁ x) = x := λ ⟨x, y, z⟩, by simp[f₁]
lemma nat.sub_sub' (a:ℕ){ b c : ℕ} : c ≤ b → b ≤ a → a - (b - c) = (a - b) + c := begin
  assume h h₁,rw [←int.coe_nat_eq_coe_nat_iff,int.coe_nat_add,int.coe_nat_sub,int.coe_nat_sub,int.coe_nat_sub],simp,
  assumption,assumption,exact le_trans (nat.sub_le b c) h₁,
end

lemma prime_not_square {n :ℕ} : ¬ nat.prime (n^2):=begin
  assume hn,
  unfold nat.pow nat.prime at hn,simp at hn,
  have := hn.right n (dvd_mul_left n n),
  cases this,rw this at hn, simp at hn,
  exact absurd hn dec_trivial,rw ← this at hn,
  have h1 : (↑n:ℤ)≠0, rw ←int.coe_nat_zero,
   assume h, have:=int.coe_nat_inj h,rw this at hn, exact absurd hn.left dec_trivial,
   rw [←int.coe_nat_eq_coe_nat_iff,int.coe_nat_mul] at this,
  have := eq_one_of_mul_eq_self_left h1 this.symm,
  rw ←int.coe_nat_one at this, have:=int.coe_nat_inj this,rw this at hn,
  exact absurd hn.left dec_trivial,
end
lemma eq_one_of_mul_eq_self : ∀ a b :ℕ, a > 0 → a * b = a → b = 1:=begin
  assume a b ha hab,cases b,simp at hab,rw ←hab at ha,exact absurd ha dec_trivial,
  cases b,reflexivity,rw nat.mul_succ at hab,
  have :a * nat.succ b + a - a = a -a,rw hab,
  rw [nat.add_sub_cancel,nat.sub_self] at this,
  have:=nat.eq_zero_of_mul_eq_zero this,cases this,
  rw this_1 at ha,exact absurd ha dec_trivial,
  rw this_1,
end

lemma f₂_S (hp : nat.prime p) (hp1 : p ≡ 1 [MOD 4]) : ∀ x : (ℕ × ℕ × ℕ), x ∈ S p → f₂ x ∈ S p := λ ⟨x, y, z⟩, begin
  unfold f₂ S,assume h,simp at h,
  have gx : -(2 * ((↑x:ℤ) * ↑y)) + (-(2 * (↑x * ↑y))) = - (4 * ((↑x:ℤ) * ↑y)),
    rw [←neg_add,←mul_add (2:ℤ)],
    have : (↑x * ↑y + ↑x * ↑y:ℤ) = 2 * (↑x * ↑y),
      rw [(dec_trivial : (2:ℤ) = 1 + 1),add_mul,one_mul],
    rw [this,←mul_assoc,(dec_trivial : (2:ℤ) * 2 = 4)],
  
  cases classical.em (x + z < y),
  simp[h_1],split,rw ←h.left,
  have hx : (x + 2 * z) * (x + 2 * z) = x * x + 4 * x * z + 4 * z * z,
    rw[mul_add,add_mul,add_mul],simp[mul_comm,mul_assoc,mul_left_comm],
    rw [(dec_trivial : 2 * 2 = 4),← add_assoc,←mul_assoc x,←add_mul],
    have : x * z + x * z = x * z * 2,rw [nat.mul_succ,mul_one],
    rw this,rw [mul_assoc(x * z),(dec_trivial : 2 * 2 = 4),mul_assoc],

  
  rw hx,rw [←neg_add,←int.coe_nat_add,←sub_eq_add_neg,←int.coe_nat_sub (le_of_lt h_1),nat_abs_of_nat],
  rw [←nat.sub_sub],
  
  
  rw [nat.mul_sub_left_distrib,nat.mul_sub_left_distrib],
  simp[mul_comm,mul_assoc,mul_left_comm],rw[add_comm (z *(z *4)),eq_comm,←add_assoc,←@nat.sub_eq_iff_eq_add _ (z * (z*4)),add_comm (x * (z * 4)),←@nat.sub_eq_iff_eq_add _ (x * (z*4)),nat.sub_sub,nat.sub_sub,add_comm],
  rw ←nat.mul_sub_right_distrib,rw mul_le_mul_right (show z * 4 > 0, from mul_pos h.right.right.right dec_trivial),rw nat.le_sub_right_iff_add_le,exact le_of_lt h_1,
  exact le_of_lt (lt_of_le_of_lt (nat.le_add_left z x) h_1),
  rw mul_le_mul_right,exact le_of_lt (lt_of_le_of_lt (nat.le_add_left z x) h_1),
  exact mul_pos h.right.right.right dec_trivial,split,
  exact lt_of_lt_of_le h.right.left (nat.le_add_right _ _),split,
  exact h.right.right.right,
  have := nat.sub_pos_of_lt h_1,
  rwa [←neg_add,←int.coe_nat_add,←sub_eq_add_neg,←int.coe_nat_sub (le_of_lt h_1),nat_abs_of_nat],
  simp [h_1],
  have hxzy : 0 < ((↑x + (↑z + -↑y)): ℤ),
    rw ←add_assoc, rw ←sub_lt_iff,simp,rw[←int.coe_nat_add,int.coe_nat_lt],cases (lt_or_eq_of_le (le_of_not_gt h_1)),
    assumption,rw h_2 at h,
    have : p= (x + 2 * z)^2,simp [nat.pow],
      rw[add_mul,mul_add,mul_add],rw ←h.left,
      simp,rw [mul_add,add_mul],
      have : 2 * z * (2 * z) = 4 * z * z,
        rw [mul_left_comm,←mul_assoc,←mul_assoc,(dec_trivial : 2 * 2 = 4)],rw this,
      rw ←add_assoc,
      have : x * (2 * z) + 2 * z * x = 4 * x * z,
        rw [mul_left_comm], rw mul_comm x,rw ←mul_assoc, rw ←mul_add,
        have: x + x = 2 * x,rw nat.succ_mul,simp,
        rw this,rw mul_left_comm,rw[←mul_assoc,←mul_assoc, (dec_trivial : 2 * 2 = 4)],rw mul_right_comm,
      rw this, 
    rw this at hp,exact absurd hp prime_not_square,
  cases classical.em (2 * y < x),
  have hx2y : 0 < (↑x + -(2 * ↑y): ℤ),
    rw ←sub_lt_iff,simp,have :(2:ℤ) = ↑(2:ℕ),simp,exact dec_trivial,
    rw [this,←int.coe_nat_mul,int.coe_nat_lt],exact h_2,
  simp [h_2],  
  split,rw ←h.left,
  rw [←int.coe_nat_eq_coe_nat_iff,int.coe_nat_add,int.coe_nat_mul,int.coe_nat_mul,int.coe_nat_add,int.coe_nat_mul,int.coe_nat_mul,int.coe_nat_mul,int.coe_nat_mul],
  have h_11 := le_of_not_gt h_1,
  rw nat_abs_of_nonneg (int.le_of_lt hxzy),rw nat_abs_of_nonneg (int.le_of_lt hx2y),
  rw [mul_add,mul_add,mul_add,add_mul,add_mul,add_mul,add_mul],have : (4:ℤ) = ↑(4 : ℕ),simp,exact_dec_trivial, rw ←this,
  rw [←add_assoc (↑x * ↑x + -(2 * ↑y) * ↑x:ℤ)],
  simp[mul_comm,mul_assoc,mul_left_comm],
  
  rw [←add_assoc,gx,neg_add_cancel_left,←mul_assoc (2:ℤ),(dec_trivial : (2:ℤ)*2=4),neg_add_self,add_zero],
  rw [←int.coe_nat_lt,←int.coe_nat_lt,int.coe_nat_zero],
  rw nat_abs_of_nonneg (int.le_of_lt hxzy),rw nat_abs_of_nonneg (int.le_of_lt hx2y),simp [hx2y,hxzy],exact h.right.right.left,
  
 
  simp[h_1,h_2,h.right.right.left],
  rw [←int.coe_nat_lt,←int.coe_nat_lt,int.coe_nat_zero],rw nat_abs_of_nonneg (int.le_of_lt hxzy),simp[hxzy],
  have hx2y :0 < (-↑x + 2 * ↑y:ℤ),
    rw add_comm,rw ←sub_lt_iff,simp,
    cases lt_or_eq_of_le (le_of_not_gt h_2),have : ↑(2:ℕ) = (2:ℤ), simp,exact dec_trivial,
    rw ←this,rwa [←int.coe_nat_mul,int.coe_nat_lt],
    rw [h_3,mul_left_comm,←mul_assoc,←mul_assoc, (dec_trivial : 2 * 2 = 4), ←mul_add,mul_assoc] at h,
    have:=dvd_mul_right 4 (y * (y + z)),rw ←nat.modeq.modeq_zero_iff at this,rw h.left at this,
    have := this.symm.trans hp1, exact absurd this dec_trivial,
  rw [←int.coe_nat_lt,int.coe_nat_zero],rw nat_abs_of_nonneg (int.le_of_lt hx2y),
  simp[hx2y],
  rw[←int.coe_nat_eq_coe_nat_iff,int.coe_nat_add,int.coe_nat_mul,int.coe_nat_mul,int.coe_nat_mul],
  rw [nat_abs_of_nonneg (int.le_of_lt hxzy),nat_abs_of_nonneg (int.le_of_lt hx2y)],
  rw (dec_trivial : ↑4 = (4: ℤ )),
  rw [← h.left,int.coe_nat_add,int.coe_nat_mul,int.coe_nat_mul,int.coe_nat_mul,mul_add,mul_add,mul_add,add_mul,add_mul],
  have : (2:ℤ) * (↑y: ℤ) * (2 * ↑y)  = 4 * ↑y * ↑y,
    rw [mul_left_comm, ←mul_assoc, ←mul_assoc, (dec_trivial : (2:ℤ) * 2 = 4)],
  rw this,
  have : (2:ℤ) * ↑y * -↑x + (-↑x * (2 * ↑y)) = -(4 * ↑x * ↑y),
    simp[mul_comm,mul_assoc,mul_left_comm],rw [←neg_add,←mul_add],
    have : (↑x : ℤ) * ↑ y + ↑x * ↑y = 2 * (↑x * ↑y),
      rw [←one_mul ((↑x:ℤ) * ↑y),←add_mul, (dec_trivial : (1:ℤ) + 1 = 2)],
      simp,
    rw [this,←mul_assoc,(dec_trivial : (2:ℤ) * 2 = 4)],
  rw [add_assoc (-(↑x:ℤ) * -↑x),←add_assoc ((2:ℤ) * ↑y * -↑x),this,←add_assoc ( (4:ℤ) * ↑y * ↑x)],rw ←(dec_trivial : (4 :ℤ)= ↑(4:ℕ) ),
  simp[mul_comm,mul_assoc,mul_left_comm],rw [add_comm ((4:ℤ) * (↑y * ↑z)),add_neg_cancel_left],
end
lemma f₂_invo_on_S : ∀ x : (ℕ × ℕ × ℕ), x ∈ S p → f₂ (f₂ x) = x:= λ⟨x,y,z⟩,begin
  assume h,unfold f₂, simp,simp [S] at h,
  cases classical.em (x + z < y),
  simp[h_1],unfold f₂._match_1,
  cases classical.em (x + 2 * z + nat_abs (↑y + (-↑x + -↑z)) < z),
  simp [h_2],
  rw [←neg_add,←int.coe_nat_add,←sub_eq_add_neg,←int.coe_nat_sub (le_of_lt h_1),nat_abs_of_nat] at *,
  exfalso,
  rw [nat.succ_mul,one_mul,add_left_comm] at h_2,simp only [add_assoc] at h_2,
  exact not_lt_of_ge (nat.le_add_right z (x + (z + (y - (x + z))))) h_2,
  simp[h_2],simp[h.right.left],rw [(dec_trivial : (1:ℤ)+1 =2),add_neg_self,add_zero,nat_abs_of_nat],simp [(rfl:x=x)],
  
  rw [←neg_add,←int.coe_nat_add,←sub_eq_add_neg,←int.coe_nat_sub (le_of_lt h_1),nat_abs_of_nat,int.coe_nat_sub (le_of_lt h_1),int.coe_nat_add],
  rw [(dec_trivial : (2:ℤ)=1+1),add_mul,one_mul,add_assoc (↑z:ℤ),add_neg_cancel_left,sub_eq_add_neg,add_comm (↑y:ℤ),←add_assoc (↑x:ℤ),add_neg_cancel_left,nat_abs_of_nat],
  simp[h_1],
  have h_11:=le_of_not_gt h_1,
  cases classical.em (2 * y < x),
  simp[h_2],unfold f₂._match_1,
  have h_3 : nat_abs (↑x + -(2 * ↑y)) + y < nat_abs (↑x + (↑z + -↑y)),
    rw[←sub_eq_add_neg,(dec_trivial : (2:ℤ)= ↑2),←int.coe_nat_mul,←int.coe_nat_sub (le_of_lt h_2),nat_abs_of_nat,←sub_eq_add_neg,add_sub,←int.coe_nat_add,←int.coe_nat_sub h_11,nat_abs_of_nat,←nat.sub_add_comm(le_of_lt h_2),nat.succ_mul,one_mul,←nat.sub_sub,nat.add_sub_cancel,nat.lt_sub_left_iff_add_lt h_11,←nat.add_sub_assoc,nat.add_sub_cancel_left],
    rw lt_add_iff_pos_right,exact h.right.right.right,
    rw [nat.succ_mul,one_mul] at h_2,
    exact le_trans (nat.le_add_left y y) (le_of_lt h_2),
  simp[h_3],
  rw[←sub_eq_add_neg,(dec_trivial : (2:ℤ)= ↑2),←int.coe_nat_mul,←int.coe_nat_sub (le_of_lt h_2),nat_abs_of_nat,←nat.add_sub_assoc (le_of_lt h_2),nat.add_sub_cancel_left],simp[(rfl:x=x)],
  rw [←sub_eq_add_neg (↑z:ℤ),←add_sub_assoc,←int.coe_nat_add,←int.coe_nat_sub h_11,nat_abs_of_nat,int.coe_nat_sub,nat.succ_mul,one_mul,int.coe_nat_add,int.coe_nat_sub h_11,int.coe_nat_add],simp,
  rw[add_comm,add_assoc],simp,exact le_of_lt h_2,simp[h_2],
  unfold f₂._match_1,
  have h_21:=le_of_not_gt h_2,
  have h_211 : x ≤ y + y,
    rwa [nat.succ_mul,one_mul]at h_21,
  rw[←sub_eq_add_neg,(dec_trivial : (2:ℤ)= ↑2),←int.coe_nat_mul,←int.coe_nat_sub h_21,nat_abs_of_nat,←sub_eq_add_neg,←add_sub_assoc,←int.coe_nat_add,←int.coe_nat_sub h_11,nat_abs_of_nat,nat.succ_mul,one_mul,←nat.add_sub_assoc h_11,←nat.sub_add_comm h_211,add_comm x,←add_assoc,nat.add_sub_cancel,add_right_comm,nat.add_sub_cancel],
  simp[not_lt_of_ge (nat.le_add_right y z)],simp[not_lt_of_ge (nat.sub_le (y+y) x)],
  rw[int.coe_nat_sub h_211,int.coe_nat_add,int.coe_nat_sub h_11],simp,rw [add_comm((↑z:ℤ)), add_neg_cancel_left,nat_abs_of_nat],
end
lemma f₂_fixed_point (hp : nat.prime p) (hp1 : p ≡ 1 [MOD 4]) : ∃! x : (ℕ × ℕ × ℕ), x ∈ S p ∧ f₂ x = x := begin
  
  existsi (1,1,(p/4)),simp [S],unfold nat.modeq at hp1,simp[(dec_trivial:1%4=1)] at hp1,
  have hp₁:=nat.mod_add_div p 4,rw hp1 at hp₁,simp[hp₁], 
  simp[(dec_trivial : 0<1)],
  have : 0 < p / 4,
    apply by_contradiction,
    assume h,have h₁:=nat.eq_zero_of_le_zero (le_of_not_gt h),simp[h₁] at hp₁,rw ←hp₁ at hp,
    exact absurd (nat.prime.gt_one hp) dec_trivial,
  simp[this],unfold f₂,
  have : ¬(1 + p / 4 < 1),
    rw [nat.one_add],assume h,
    have:=nat.lt_of_succ_lt_succ h,
    exact not_lt_of_ge (nat.zero_le (p/4)) this,
  simp[this],
  simp[(dec_trivial:¬2<1)],
  simp[(dec_trivial:nat_abs (2 + -1) = 1)],
  assume x y,cases y with y z,simp,
  assume h hx hy hz,
  unfold f₂._match_1,
  assume hb,
  cases classical.em (x + z < y),
  simp[h_1] at hb,rw ←add_zero x at hb,
  have:=add_left_cancel hb.left,
  rw [nat.succ_mul,one_mul] at this,
  have:=nat.eq_zero_of_add_eq_zero this,rw this.left at hz,
  exact absurd hz dec_trivial,simp[h_1] at hb,
  cases classical.em (2 * y < x),
  simp [h_2] at hb,
  rw [(dec_trivial : (2:ℤ) = ↑2),←int.coe_nat_mul,←sub_eq_add_neg,←int.coe_nat_sub (le_of_lt h_2),nat_abs_of_nat] at hb,
  rw nat.sub_eq_iff_eq_add (le_of_lt h_2) at hb,
  rw [←add_zero x] at hb,
  have:=add_left_cancel hb.left,
  rw [nat.succ_mul,one_mul] at this,
  have:=nat.eq_zero_of_add_eq_zero this.symm,rw this.left at hy,
  exact absurd hy dec_trivial,
  simp[h_2] at hb,
  have h_3 := le_of_not_gt h_2,
  rw [(dec_trivial : (2:ℤ) = ↑2),←int.coe_nat_mul,←sub_eq_add_neg,←int.coe_nat_sub h_3,nat_abs_of_nat] at hb,
  rw nat.sub_eq_iff_eq_add h_3 at hb,
  have hyx : y=x,
    have : 2 * y = 2 * x,
      rw [nat.succ_mul 1 x,one_mul] , exact hb.left,
    have : (2 * y) / 2 = (2 * x) / 2,
      rw this,
    rwa [nat.mul_div_cancel_left _ (dec_trivial:2>0),nat.mul_div_cancel_left _ (dec_trivial:2>0)] at this,
  rw [hyx, mul_comm 4,mul_assoc,←mul_add] at h,
  have:=dvd_mul_right x (x + 4 * z),rw h at this,have:=hp.right x this,
  cases this,rw hyx, simp[this_1],rw this_1 at h,simp at h,rw ←hp₁ at h,simp at h,
  have : (4*z)/4 = (4*(p/4)/4),
    rw h,
  rwa [nat.mul_div_cancel_left _ (dec_trivial:4>0),nat.mul_div_cancel_left _ (dec_trivial:4>0)] at this,
  rw this_1 at h,
  exfalso,
  have:=eq_one_of_mul_eq_self p (p+4*z) (nat.prime.pos hp) h,
  have h:= nat.le_add_right p (4*z),rw this at h,
  exact absurd h (not_le_of_gt (nat.prime.gt_one hp)),
end
theorem fermat_sum_two_squares {p : ℕ} : nat.prime p → p ≡ 1 [MOD 4] → ∃ a b : ℕ, a^2 + b^2 = p := begin
  assume hp hp1,have : card (S p) ≡ 1 [MOD 2],
  cases (f₂_fixed_point p hp hp1) with x hx,
  let s := {y : (ℕ × ℕ × ℕ) | y ≠ x ∧ y ∈ S p},
  have is : fintype s,
    let f : {y : (ℕ × ℕ × ℕ) | y ≠ x ∧ y ∈ S p} → S p := λ y, ⟨y,begin cases y,simp at y_property,simp[subtype.coe_mk],exact y_property.right,end⟩,
    have : function.injective f,
      assume a b,simp[f],cases a, cases b,simp [subtype.coe_mk],
    simp[s],
    exact fintype_of_injective this,
  have hx₁:(x ∈ S p ∧ f₂ x = x) ∧ ∀ (y : ℕ × ℕ × ℕ), ( y ∈ S p ∧ f₂ y = y) → y = x := hx,clear hx,
  let f₂' : {y : (ℕ × ℕ × ℕ) | y ≠ x ∧ y ∈ S p} → {y : (ℕ × ℕ × ℕ) | y ≠ x ∧ y ∈ S p} := λ y, ⟨f₂ y,begin simp,split,
    intro,have:= hx₁.left.right,rw ←a at this,cases y,
    simp only [subtype.coe_mk] at *,simp at y_property,
    have t₁:= f₂_invo_on_S p y_val y_property.right,rw [←this,t₁] at a,exact y_property.left a,
    cases y,simp at y_property,
    simp[subtype.coe_mk],exact f₂_S p hp hp1 y_val y_property.right,
      end⟩,
    have hf₁1: ∀ y : ↥{y : ℕ × ℕ × ℕ | y ≠ x ∧ y ∈ S p}, f₂' y ≠ y,
      assume y,
      cases y,simp[subtype.coe_mk],simp at y_property,assume hy,
      exact y_property.left (hx₁.right y_val ⟨y_property.right, hy⟩),
    have hf₁2: ∀ y : ↥{y : ℕ × ℕ × ℕ | y ≠ x ∧ y ∈ S p}, f₂' (f₂' y) = y,
      assume y,cases y, simp[subtype.coe_mk,f₂'],
      exact f₂_invo_on_S p y_val y_property.right,
    have := involution_parity hf₁1 hf₁2,
    have hx₂ : x ∉ {y : ℕ × ℕ × ℕ | y ≠ x ∧ y ∈ S p},
      simp,
    have i : set.finite s := ⟨is⟩,
    let i₁ := set.finite.to_finset i,
    have hx₂ : x ∉ i₁, simp [i₁],
    have hi₁:=finset.card_insert_of_not_mem hx₂,
    have hi₁2 : ∀ y :  ℕ × ℕ × ℕ , y ∈ i₁ ↔ y ∈ s,assume y,
      simp [i₁],
    have h := set.card_fintype_of_finset' i₁ hi₁2,
    rw ←h at hi₁,
    have h₂: ∀ y : ℕ × ℕ × ℕ, y ∈ insert x i₁ ↔ y ∈ S p,assume y,simp,
      split,
      assume h,cases h,
      rw h_1, exact hx₁.left.left,
      exact h_1.right,
      assume h,
      cases classical.em (y=x),
      exact or.inl h_1,
      exact or.inr ⟨h_1,h⟩,
    rw ←set.card_fintype_of_finset' _ h₂ at hi₁,rw hi₁,
    suffices h : card ↥s ≡ 0 [MOD 2],
    exact nat.modeq.modeq_add h (nat.modeq.refl 1),
    rw nat.modeq.modeq_zero_iff,simp[s],
    exact this,
  let f₁' : (S p) →  S p := λ y, ⟨f₁ (↑y : ℕ × ℕ × ℕ),begin cases y,simp [subtype.coe_mk],
    exact f₁_S p y_val y_property,
  end⟩,
  have hf₁_invo : ∀ y : S p, f₁' (f₁' y) = y,
    assume y, cases y,
    simp [f₁'],exact f₁_invo_on_S p y_val y_property,
  have : ∃ y : S p, f₁' y = y,
    apply by_contradiction,
    assume h, rw not_exists at h,
    have h₃:=involution_parity h hf₁_invo,
    rw ←nat.modeq.modeq_zero_iff at h₃,
    have:=this.symm.trans h₃,
    simp[nat.modeq,(dec_trivial : ¬1%2=0)] at this,
    trivial,
  cases this with x hx,
  cases x with x hx₁,
  cases x with x y,
  cases y with y z,
  simp [S] at hx₁,
  existsi [x, 2*y],
  unfold nat.pow,
  simp [f₁',f₁] at hx,
  rw [←hx₁.left,hx.left],
  simp,rw [mul_left_comm (2*y),←mul_assoc,←mul_assoc,(dec_trivial : 2 * 2 = 4)],
end
#print axioms fermat_sum_two_squares
